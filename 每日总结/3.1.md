inline关键字的三大作用：

inline void cudaCheck_(...) { ... }
1. 性能优化：消除函数调用开销（压栈/弹栈操作）适合频繁调用的小函数（CUDA程序通常每个API调用后都要检查）
2. 避免重复定义：多文件包含时，inline函数允许在头文件中定义。普通函数在头文件中多次包含会导致链接错误
3. 逻辑内联：使错误处理逻辑与调用代码紧密结合。编译器能更好地优化错误处理分支（如将错误分支预测为冷路径）


std:swap函数是如何实现的？？？


# constexpr
constexpr 的设计初衷是为了在编译期间就确定某些变量或函数的值，从而带来更高效的程序性能和更强的类型安全。

具体来说，它的出现主要有以下几个目的：

编译期求值：使用 constexpr 可以让编译器在编译期计算出表达式的值，这样在运行时就不需要再重新计算。这在定义数组大小、模板参数或者其他需要常量值的场合非常有用。

与 const 的区别和改进：虽然使用 const 也能定义不可变的变量，但 const 并不保证变量在编译期间就能求值。而 constexpr 不仅要求变量不可变，而且要求它的值在编译期就可确定。这样能更好地发挥编译器的优化潜力。

提高代码表达力和安全性：通过 constexpr，可以显式表示某些值或函数应当在编译期求值，这不仅能让程序更加清晰明确，还能在编译阶段捕获错误，比如如果表达式无法在编译期求值，编译器就会报错，从而减少运行时隐患。

支持编译时计算的函数（constexpr 函数）：constexpr 不仅可以修饰变量，还可以用于函数。constexpr 函数要求其函数体在编译期间能够求值（对于某些调用场景），从而可以在编译时期就获得函数的计算结果。这使得一些本来只能在运行时求值的计算可以在编译期完成，进一步提升程序效率。


总的来说，constexpr 的引入是为了提供一个机制，允许程序员指定和保证某些数据或计算在编译期就能得出，不仅有助于编译器进行优化，而且能让代码在性能和表达意图上都有较大的改进。